// Autogenerated by Frugal Compiler (2.15.1)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

package gateway_test

import (
	"bytes"
	"fmt"
	"io"
	"log"
	"net/http"
	"strings"

	"git.apache.org/thrift.git/lib/go/thrift"
	"github.com/Sirupsen/logrus"
	"github.com/Workiva/frugal/lib/gateway"
	"github.com/Workiva/frugal/lib/go"
	"github.com/gorilla/mux"
)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = bytes.Equal
var _ = logrus.DebugLevel

// GatewayTestContext forwards HTTP requests to a Frugal service
type GatewayTestContext struct {
	Client     *FGatewayTestClient
	Marshalers gateway.MarshalerRegistry
}

// GatewayTestHandler is a wrapper to provide context to HTTP handlers
type GatewayTestHandler struct {
	*GatewayTestContext

	// ContextHandlerFunc is the interface which our Handlers will implement
	ContextHandlerFunc func(*GatewayTestContext, http.ResponseWriter, *http.Request) (int, error)
}

// ServeHTTP handles HTTP requests with an included context
func (handler GatewayTestHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	status, err := handler.ContextHandlerFunc(handler.GatewayTestContext, w, r)
	if err != nil {
		log.Printf("HTTP %d: %q", status, err)
		switch status {
		// TODO:
		// customize error handling using context
		}
	}

}

// GatewayTestGetContainerHandler forwards HTTP requests to a Frugal service
func GatewayTestGetContainerHandler(context *GatewayTestContext, responseWriter http.ResponseWriter, request *http.Request) (int, error) {
	flusher, _ := responseWriter.(http.Flusher)

	inMarshaler, outMarshaler := context.Marshalers.MarshalerForRequest(request)

	// Assemble a Frugal payload of the correct type
	payload := &BaseType{}

	decoder := inMarshaler.NewDecoder(request.Body)
	defer request.Body.Close()
	err := decoder.Decode(payload)
	if err != nil && err != io.EOF {
		panic(err) // TODO: Customize error handling
	}

	// Combine path and query parameters into map[string]string.
	// If there are duplicate query parameters, only the first is respected.
	vars := mux.Vars(request)
	queries := request.URL.Query()
	for k, v := range queries {
		vars[k] = v[0]
	}

	// Map any path or query parameters into the payload
	s := gateway.NewStruct(payload)
	for k, v := range vars {
		if k == "boolTest" {
			c, err := gateway.String(v)
			if err != nil {
				panic(err)
			}
			f := s.Field("BoolTest")
			if strings.Contains(f.Tag("json"), "omitempty") {
				err = f.Set(&c)
			} else {
				err = f.Set(c)
			}

		}
		if k == "byteTest" {
			c, err := gateway.String(v)
			if err != nil {
				panic(err)
			}
			f := s.Field("ByteTest")
			if strings.Contains(f.Tag("json"), "omitempty") {
				err = f.Set(&c)
			} else {
				err = f.Set(c)
			}

		}
		if k == "i16Test" {
			c, err := gateway.String(v)
			if err != nil {
				panic(err)
			}
			f := s.Field("I16Test")
			if strings.Contains(f.Tag("json"), "omitempty") {
				err = f.Set(&c)
			} else {
				err = f.Set(c)
			}

		}
		if k == "i32Test" {
			c, err := gateway.String(v)
			if err != nil {
				panic(err)
			}
			f := s.Field("I32Test")
			if strings.Contains(f.Tag("json"), "omitempty") {
				err = f.Set(&c)
			} else {
				err = f.Set(c)
			}

		}
		if k == "i64Test" {
			c, err := gateway.String(v)
			if err != nil {
				panic(err)
			}
			f := s.Field("I64Test")
			if strings.Contains(f.Tag("json"), "omitempty") {
				err = f.Set(&c)
			} else {
				err = f.Set(c)
			}

		}
		if k == "doubleTest" {
			c, err := gateway.String(v)
			if err != nil {
				panic(err)
			}
			f := s.Field("DoubleTest")
			if strings.Contains(f.Tag("json"), "omitempty") {
				err = f.Set(&c)
			} else {
				err = f.Set(c)
			}

		}
		if k == "binaryTest" {
			fmt.Errorf("Unsupported conversion of type binary")
		}
		if k == "differentString" {
			c, err := gateway.String(v)
			if err != nil {
				panic(err)
			}
			f := s.Field("StringTest")
			if strings.Contains(f.Tag("json"), "omitempty") {
				err = f.Set(&c)
			} else {
				err = f.Set(c)
			}

		}
	}

	// Call the Frugal client with the assembled payload
	response, err := context.Client.GetContainer(frugal.NewFContext(""), payload)
	if err != nil {
		panic(err) // TODO: Customize error handling
	}

	// Serialize the Frugal response into a JSON response
	buf, err := outMarshaler.Marshal(response)
	if err != nil {
		panic(err) // TODO: Customize error handling
	}
	responseWriter.WriteHeader(http.StatusOK)
	responseWriter.Write(buf)
	flusher.Flush()

	return http.StatusOK, nil
}

// MakeRouter builds a multiplexed router handling HTTP+JSON requests according to IDL annotations
func MakeRouter(context *GatewayTestContext) (*mux.Router, error) {
	router := mux.NewRouter()
	handler := &GatewayTestHandler{context, GatewayTestGetContainerHandler}
	router.Methods("POST").Path("/v1/{differentString}/").Name("GatewayTestGetContainerHandler").Handler(handler)

	return router, nil
}
